<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis源码解读之Configuration（一）]]></title>
    <url>%2F2018%2F08%2F18%2F20180818-Mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8BConfiguration%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言Mybatis操作数据库的逻辑是在SqlSession中来实现的，SqlSession为我们提供了多种操作方法。而我们在创建SqlSession时可以使用Mybatis提供的SqlSessionFactory来创建SqlSession。如下代码为SqlSessionFactory接口提供的方法： 1234567891011public interface SqlSessionFactory &#123; SqlSession openSession(); SqlSession openSession(boolean autoCommit); SqlSession openSession(Connection connection); SqlSession openSession(TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType); SqlSession openSession(ExecutorType execType, boolean autoCommit); SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType, Connection connection); Configuration getConfiguration();&#125; Mybatis提供了SqlSessionFactoryBuilder来创建SqlSessionFactory，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 //以下代码为SqlSessionFactoryBuilder比较关键的方法public class SqlSessionFactoryBuilder &#123; //... //省略代码 //... public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123; try &#123; XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); //创建XMLConfigBuilder，并调用parse方法生成Configuration对象 return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error building SqlSession.", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; //... //省略代码 //... public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123; try &#123; XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); //创建XMLConfigBuilder，并调用parse方法生成Configuration对象 return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error building SqlSession.", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; inputStream.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; //创建DefaultSqlSessionFactory，并传入Configuration public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125;&#125; 我们可以看出，SqlSessionFactoryBuilder所有的方法最终都会调用 SqlSessionFactorybuild(Configuration config) 方法，而这之前会使用XMLConfigBuilder创建Configuration，那Configuration到时是什么，接下来的文章我们来一探究竟。 Configuration简单介绍Configuration是Mybatis的全局配置信息，并且在整个执行流程中进行传递。 主要成员变量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//环境设置protected Environment environment;//二级级缓存设置 protected boolean cacheEnabled = true;//一级缓存设置，默认为SESSION级别 protected LocalCacheScope localCacheScope = LocalCacheScope.SESSION;//懒加载触发函数 protected Set&lt;String&gt; lazyLoadTriggerMethods = new HashSet&lt;&gt;(Arrays.asList("equals", "clone", "hashCode", "toString"));//ResultSet类型 protected ResultSetType defaultResultSetType;//Executor类型，默认为SIMPLE protected ExecutorType defaultExecutorType = ExecutorType.SIMPLE;//反射工厂 protected ReflectorFactory reflectorFactory = new DefaultReflectorFactory();//对象工厂 protected ObjectFactory objectFactory = new DefaultObjectFactory();//对象包装器工厂 protected ObjectWrapperFactory objectWrapperFactory = new DefaultObjectWrapperFactory();//懒加载 protected boolean lazyLoadingEnabled = false;//#224 Using internal Javassist instead of OGNL protected ProxyFactory proxyFactory = new JavassistProxyFactory(); //数据库Id protected String databaseId; /** * Configuration factory class. * Used to create Configuration for loading deserialized unread properties. */ protected Class&lt;?&gt; configurationFactory;//用于创建MapperProxyFactory，并生成动态代理对象 protected final MapperRegistry mapperRegistry = new MapperRegistry(this);//保存多个拦截器 protected final InterceptorChain interceptorChain = new InterceptorChain(); protected final LanguageDriverRegistry languageRegistry = new LanguageDriverRegistry();//存储MappedStatement protected final Map&lt;String, MappedStatement&gt; mappedStatements = new StrictMap&lt;MappedStatement&gt;("Mapped Statements collection") .conflictMessageProducer((savedValue, targetValue) -&gt; ". please check " + savedValue.getResource() + " and " + targetValue.getResource());//存储缓存 protected final Map&lt;String, Cache&gt; caches = new StrictMap&lt;&gt;("Caches collection");//存储映射结果 protected final Map&lt;String, ResultMap&gt; resultMaps = new StrictMap&lt;&gt;("Result Maps collection");//存储参数映射信息 protected final Map&lt;String, ParameterMap&gt; parameterMaps = new StrictMap&lt;&gt;("Parameter Maps collection");//存储主键生成器 protected final Map&lt;String, KeyGenerator&gt; keyGenerators = new StrictMap&lt;&gt;("Key Generators collection"); //存储sql片段 protected final Map&lt;String, XNode&gt; sqlFragments = new StrictMap&lt;&gt;("XML fragments parsed from previous mappers"); /* * A map holds cache-ref relationship. The key is the namespace that * references a cache bound to another namespace and the value is the * namespace which the actual cache is bound to. */ protected final Map&lt;String, String&gt; cacheRefMap = new HashMap&lt;&gt;(); 创建过程在前面介绍过，通过调用XMLConfigBuilder的parse方法获取Configuration，我们接下来来看看具体的过程。 XMLConfigBuilderXMLConfigBuilder类是用于解析XML配置文件，主要包括properties，settings，typeAliases，plugins，objectFactory，objectWrapperFactory，reflectorFactory，environments，databaseIdProvider，typeHandlers，mappers等节点。配置文档的顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） parse方法parse会先判断是否已经进行解析，然后调用parseConfiguration对每个节点进行解析。 12345678910111213141516171819202122232425262728293031323334353637383940414243public Configuration parse() &#123; //只能解析一次 if (parsed) &#123; throw new BuilderException("Each XMLConfigBuilder can only be used once."); &#125; parsed = true; parseConfiguration(parser.evalNode("/configuration")); return configuration; &#125; private void parseConfiguration(XNode root) &#123; try &#123; //issue #117 read properties first //解析properties节点 propertiesElement(root.evalNode("properties")); Properties settings = settingsAsProperties(root.evalNode("settings")); loadCustomVfs(settings); loadCustomLogImpl(settings); //解析typeAliases节点 typeAliasesElement(root.evalNode("typeAliases")); //解析plugins节点 pluginElement(root.evalNode("plugins")); //解析objectFactory节点 objectFactoryElement(root.evalNode("objectFactory")); //解析objectWrapperFactory节点 objectWrapperFactoryElement(root.evalNode("objectWrapperFactory")); //解析reflectorFactory节点 reflectorFactoryElement(root.evalNode("reflectorFactory")); //解析settings节点 settingsElement(settings); // read it after objectFactory and objectWrapperFactory issue #631 //解析environments节点 environmentsElement(root.evalNode("environments")); //解析databaseIdProvider节点 databaseIdProviderElement(root.evalNode("databaseIdProvider")); //解析typeHandlers节点 typeHandlerElement(root.evalNode("typeHandlers")); //解析mappers节点 mapperElement(root.evalNode("mappers")); &#125; catch (Exception e) &#123; throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e); &#125; &#125; properties节点解析properties节点的解析在propertiesElement方法中进行。 12345678910111213141516171819202122232425private void propertiesElement(XNode context) throws Exception &#123; if (context != null) &#123; Properties defaults = context.getChildrenAsProperties(); String resource = context.getStringAttribute("resource"); String url = context.getStringAttribute("url"); //resource和url不能同时存在 if (resource != null &amp;&amp; url != null) &#123; throw new BuilderException("The properties element cannot specify both a URL and a resource based property file reference. Please specify one or the other."); &#125; if (resource != null) &#123; //设置属性值 defaults.putAll(Resources.getResourceAsProperties(resource)); &#125; else if (url != null) &#123; //设置属性值 defaults.putAll(Resources.getUrlAsProperties(url)); &#125; Properties vars = configuration.getVariables(); if (vars != null) &#123; defaults.putAll(vars); &#125; parser.setVariables(defaults); //保存属性值到configuration中 configuration.setVariables(defaults); &#125; &#125; 从源码中我们可以看出resource和url不能同时存在，不然就会抛出异常，这也规定了我们在配置文件中必须配置resource和url中的其中一个，或者都不配置。 在配置文件中可以类似下面这样设置： 1234&lt;properties resource="org/mybatis/example/config.properties"&gt; &lt;property name="username" value="dev_user"/&gt; &lt;property name="password" value="F2Fa3!33TYyg"/&gt;&lt;/properties&gt; 其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值，比如： 123456&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt;&lt;/dataSource&gt; 上面这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就使得配置变得更加的灵活。 settings节点解析settings节点中的配置项是MyBatis中非常重要的调整设置，每个设置项都有默认值，通过设置不同的值可以改变 MyBatis的运行时行为。 以下是一个配置完整的settings元素的示例： 1234567891011121314151617&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="multipleResultSetsEnabled" value="true"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt; &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt; &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt; &lt;setting name="defaultStatementTimeout" value="25"/&gt; &lt;setting name="defaultFetchSize" value="100"/&gt; &lt;setting name="safeRowBoundsEnabled" value="false"/&gt; &lt;setting name="mapUnderscoreToCamelCase" value="false"/&gt; &lt;setting name="localCacheScope" value="SESSION"/&gt; &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt;&lt;/settings&gt; 接下来我们通过源码来看看这些重要配置项的解析过程。在解析settings节点的时候，会加载自定义VFS实现类和自定义日志实现类，这时会传入settings解析后的Properties对象。 1234567Properties settings = settingsAsProperties(root.evalNode("settings"));//加载自定义VFS实现类loadCustomVfs(settings);//加载自定义日志实现类loadCustomLogImpl(settings);//解析settingsElement(settings); 加载自定义VFS实现类和自定义日志实现类我们后面再进行介绍，我们来看看settingsElement方法的具体实现。 12345private void settingsElement(Properties props) &#123; ... configuration.setCacheEnabled(booleanValueOf(props.getProperty(&quot;cacheEnabled&quot;), true)); ...&#125; settingsElement方法其实是将Properties中的属性信息存入configuration中，这一部分相对简单。 typeAliases节点解析类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，主要用来减少类完全限定名的冗余。例如： 12345678&lt;typeAliases&gt; &lt;typeAlias alias="Author" type="domain.blog.Author"/&gt; &lt;typeAlias alias="Blog" type="domain.blog.Blog"/&gt; &lt;typeAlias alias="Comment" type="domain.blog.Comment"/&gt; &lt;typeAlias alias="Post" type="domain.blog.Post"/&gt; &lt;typeAlias alias="Section" type="domain.blog.Section"/&gt; &lt;typeAlias alias="Tag" type="domain.blog.Tag"/&gt;&lt;/typeAliases&gt; 当这样配置时，可以使用 Blog 替换 所有使用 domain.blog.Blog 的地方。 也可以指定一个包名，MyBatis会在包名下面搜索需要的Java Bean，比如 123&lt;typeAliases&gt; &lt;package name="domain.blog"/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。如下： 1234@Alias("author")public class Author &#123; ...&#125; 接下来我们通过源码来看看类型别名是怎样工作的，类型别名的解析在typeAliasesElement方法中进行： 123456789101112131415161718192021222324private void typeAliasesElement(XNode parent) &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; //指定一个包名，MyBatis会在包名下面搜索需要的Java Bean if ("package".equals(child.getName())) &#123; String typeAliasPackage = child.getStringAttribute("name"); configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage); &#125; else &#123;//指定alias和type String alias = child.getStringAttribute("alias"); String type = child.getStringAttribute("type"); try &#123; Class&lt;?&gt; clazz = Resources.classForName(type); if (alias == null) &#123; typeAliasRegistry.registerAlias(clazz); &#125; else &#123; typeAliasRegistry.registerAlias(alias, clazz); &#125; &#125; catch (ClassNotFoundException e) &#123; throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e); &#125; &#125; &#125; &#125; &#125; 从源码中也验证了上面的设置规则，可以package或者alias、type来进行别名设置。 当设置alias和type 根据type获取其对应的class对象 根据alias是否为null分别调用不同的别名注册函数（registerAlias） 12345678public void registerAlias(Class&lt;?&gt; type) &#123; String alias = type.getSimpleName(); Alias aliasAnnotation = type.getAnnotation(Alias.class); if (aliasAnnotation != null) &#123; alias = aliasAnnotation.value(); &#125; registerAlias(alias, type); &#125; 在 registerAlias(Class type&gt;) 函数中，会先判断是否当前class是否包含Alias注解，有获取Alias注解中设置的值，没有的话就获取首字母小写的限定名称，然后调用 registerAlias(String alias, Class value)。 12345678910111213public void registerAlias(String alias, Class&lt;?&gt; value) &#123; if (alias == null) &#123; throw new TypeException("The parameter alias cannot be null"); &#125; // issue #748 String key = alias.toLowerCase(Locale.ENGLISH); if (typeAliases.containsKey(key) &amp;&amp; typeAliases.get(key) != null &amp;&amp; !typeAliases.get(key).equals(value)) &#123; throw new TypeException("The alias '" + alias + "' is already mapped to the value '" + typeAliases.get(key).getName() + "'."); &#125; typeAliases.put(key, value); &#125; 在 registerAlias(String, Class) 函数中，最终将别名作为key，类型作为value存入typeAliases中，typeAliases是Map&lt;String, Class&lt;?&gt;&gt;类型的。 当时设置package 获取别名所在的包 然后调用 registerAliases(String packageName) 函数进行别名注册 12345678910111213141516public void registerAliases(String packageName) &#123; registerAliases(packageName, Object.class);&#125;public void registerAliases(String packageName, Class&lt;?&gt; superType) &#123; ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(superType), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses(); for (Class&lt;?&gt; type : typeSet) &#123; // Ignore inner classes and interfaces (including package-info.java) // Skip also inner classes. See issue #6 if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) &#123; registerAlias(type); &#125; &#125;&#125; 在 registerAliases(String packageName, Class&lt;?&gt; superType) 函数中，获取当前包下的所有继承Object的类的class，然后调用 registerAlias 方法对每个class进行别名注册。 别名注册的逻辑主要在TypeAliasRegistry类中实现，后面会有具体的文章来介绍TypeAliasRegistry。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java多线程之自旋锁与自适应自旋锁]]></title>
    <url>%2F2018%2F01%2F15%2F20180115-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81%2F</url>
    <content type="text"><![CDATA[自旋锁什么是自旋阻塞或唤醒一个Java线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃 CPU 的执行时间，看看持有锁的线程是否很快就会释放锁。 而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。 自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。 自旋的优点 自旋不会发生线程转态的转换，减少不必要的上下文切换 不阻塞线程，不进行上下文切换 自旋的缺点自旋等待虽然避免了线程切换的开销，但是还是有缺点的： 自旋不能代替阻塞 自旋时间长的话会过度消耗 CPU，占用 CPU 时间 如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。 自旋的实现原理自旋锁的实现原理同样也是 CAS，AtomicInteger 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。 自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。 如何实现自旋锁下面是个简单的例子： 12345678910111213public class SpinLock &#123; private AtomicReference&lt;Thread&gt; cas = new AtomicReference&lt;Thread&gt;(); public void lock() &#123; Thread current = Thread.currentThread(); // 利用CAS while (!cas.compareAndSet(null, current)) &#123; &#125; &#125; public void unlock() &#123; Thread current = Thread.currentThread(); cas.compareAndSet(current, null); &#125;&#125; 当一个线程A进入 lock 方法后，成功获取到锁后，不会进入while循环，此时如果线程B进入 lock 方法，通过 CAS判断失败后会进入 while 循环，然后不断重复地判断是否满足条件，直到线程A调用 unlock 释放锁。 可重入自旋锁上面代码实现的自旋锁有个问题，就是同一个线程再次获取锁的时候是不能获取到锁的，也就是锁不能重入。 为了实现可重入锁，我们引入一个计数器，用来记录锁的线程数。 123456789101112131415161718192021222324public class ReentrantSpinLock &#123; private AtomicReference&lt;Thread&gt; cas = new AtomicReference&lt;Thread&gt;(); private int count; public void lock() &#123; Thread current = Thread.currentThread(); if (current == cas.get()) &#123; // 如果当前线程已经获取到了锁，线程数增加一，然后返回 count++; return; &#125; // 如果没获取到锁，则通过CAS自旋 while (!cas.compareAndSet(null, current)) &#123; &#125; &#125; public void unlock() &#123; Thread cur = Thread.currentThread(); if (cur == cas.get()) &#123; if (count &gt; 0) &#123;// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟 count--; &#125; else &#123;// 如果count==0，可以将锁释放，这样就能保证获取锁的次数与释放锁的次数是一致的了。 cas.compareAndSet(cur, null); &#125; &#125; &#125;&#125; 自适应自旋锁什么是自适应自旋 自适应意味着自旋的时间（次数）不再固定 由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。 自旋锁的分类在自旋锁中有三种常见的锁形式：TicketLock、CLHLock 和 MCSLock TicketLockTicketLock：每当有线程获取锁的时候，就给该线程分配一个递增的排队号，同时，锁对应一个服务号，每当有线程释放锁，服务号就会递增，此时如果服务号与某个线程的排队号一致，那么该线程就获得锁，由于排队号是递增的，所以就保证了最先请求获取锁的线程可以最先获取到锁，就实现了公平性。 可以想象成银行办理业务排队，排队的每一个顾客都代表一个需要请求锁的线程，而银行服务窗口表示锁，每当有窗口服务完成就把自己的服务号加一，此时在排队的所有顾客中，只有自己的排队号与服务号一致的才可以得到服务。 Ticket主要解决的是访问顺序（公平性）的问题，主要的问题是在多核CPU上。 以下是实现TicketLock的示例代码： 123456789101112131415161718192021222324252627import java.util.concurrent.atomic.AtomicInteger;public class TicketLock &#123; //当前服务号 private AtomicInteger serviceNum = new AtomicInteger(); //每个线程lock时自增，并设置到线程的ThreadLocal中 private AtomicInteger ticketNum = new AtomicInteger(); //用于保存每个线程的票号 private static final ThreadLocal&lt;Integer&gt; LOCAL = new ThreadLocal&lt;Integer&gt;(); //获取TicketLock的流程如下： //1、线程进入lock方法，原子地获取当前加1的票号 //2、将票号设置到本地线程ThreadLocal中 //3、自旋比较本地线程的票号是否和当前服务号，直至相等为止 public void lock() &#123; int myticket = ticketNum.getAndIncrement(); LOCAL.set(myticket); //如果线程持有的票号和当前的服务号不相等就自旋等待 while (myticket != serviceNum.get()) &#123;&#125; &#125; public void unlock() &#123; int myticket = LOCAL.get(); //释放锁，将服务号加1 serviceNum.compareAndSet(myticket, myticket + 1); &#125;&#125; TicketLock的缺点：每次都要读写一个serviceNum服务号，并且还要保证读写操作在多个处理器缓存之间进行同步，这样会增加系统压力，影响性能。 CLHLockCLHLock采用链表的形式进行排序，有如下好处： 公平，FIFO，先来后到的顺序进入锁 没有竞争同一个变量，因为每个线程都是在等待前继释放锁 以下是实现CLHLock的示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;public class CLHLock &#123; public static class CLHNode &#123; private volatile boolean isLocked = true; &#125; @SuppressWarnings("unused") private volatile CLHNode tail; //每个线程私有的，用于保存每个线程所对应的CLHNode节点 private static final ThreadLocal&lt;CLHNode&gt; LOCAL = new ThreadLocal&lt;CLHNode&gt;(); //用于原子地更新CLHLock中的tail字段 private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, "tail"); //获取CLHLock锁的过程： //1、新建CLHNode节点并设置到当前线程的ThreadLocal中 //2、原子地更新tail字段并获得前置节点 //3、自旋判断前置节点是否释放锁 public void lock() &#123; CLHNode node = new CLHNode(); LOCAL.set(node); CLHNode preNode = UPDATER.getAndSet(this, node); if (preNode != null) &#123; while (preNode.isLocked) &#123; &#125; //用于GC preNode = null; LOCAL.set(node); &#125; &#125; public void unlock() &#123; CLHNode node = LOCAL.get(); if (!UPDATER.compareAndSet(this, node, null)) &#123; node.isLocked = false; &#125; //用于GC node = null; &#125;&#125; CLHLock是不停的查询前驱变量， 导致不适合在NUMA 架构下使用（在这种结构下，每个线程分布在不同的物理内存区域） 这里介绍以下NUMA。非统一内存访问架构（英语：Non-uniform memory access，简称NUMA）是一种为多处理器的计算机设计的内存架构，内存访问时间取决于内存相对于处理器的位置。在NUMA下，处理器访问它自己的本地内存的速度比非本地内存（内存位于另一个处理器，或者是处理器之间共享的内存）快一些。 非统一内存访问架构的特点是：被共享的内存物理上是分布式的，所有这些内存的集合就是全局地址空间。所以处理器访问这些内存的时间是不一样的，显然访问本地内存的速度要比访问全局共享内存或远程访问外地内存要快些。另外，NUMA中内存可能是分层的：本地内存，群内共享内存，全局共享内存。 MCSLockMCSLock则是对本地变量的节点进行循环。不存在CLHlock 的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;public class MCSLock &#123; public static class MCSNode &#123; volatile MCSNode next; volatile boolean isLocked = true; &#125; private static final ThreadLocal&lt;MCSNode&gt; NODE = new ThreadLocal&lt;MCSNode&gt;(); @SuppressWarnings("unused") private volatile MCSNode queue; private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, MCSNode.class, "queue"); //获取MCSLock锁的过程： //1、新建MCSNode节点并设置到当前线程的ThreadLocal中 //2、原子地更新queue字段并获得前置节点 //3、设置前置节点的next为当前节点 //4、自旋判断当前节点是否释放锁 public void lock() &#123; MCSNode currentNode = new MCSNode(); NODE.set(currentNode); MCSNode preNode = UPDATER.getAndSet(this, currentNode); if (preNode != null) &#123; preNode.next = currentNode; while (currentNode.isLocked) &#123; &#125; &#125; &#125; public void unlock() &#123; MCSNode currentNode = NODE.get(); if (currentNode.next == null) &#123; if (UPDATER.compareAndSet(this, currentNode, null)) &#123; &#125; else &#123; while (currentNode.next == null) &#123; &#125; &#125; &#125; else &#123; currentNode.next.isLocked = false; currentNode.next = null; &#125; &#125;&#125; CLHLock和MSCLock CLH 的队列是隐式的队列，没有真实的后继结点属性。 MCS 的队列是显式的队列，有真实的后继结点属性。 线程状态借助节点保存，每个线程都有一份独有的节点，这样就解决了TicketLock多处理器下的问题。 JUC ReentrantLock 默认内部使用的锁是 CLH锁（有很多改进的地方，将自旋锁换成了阻塞锁等等）。 参考资料 https://zhuanlan.zhihu.com/p/40729293 https://tech.meituan.com/2018/11/15/java-lock.html]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java多线程之悲观锁与乐观锁]]></title>
    <url>%2F2017%2F09%2F12%2F20170912-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[前言乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。可以从以下概念来进行区分： 线程要不要锁住同步资源？ 锁住：悲观锁 不锁住：乐观锁 悲观锁概念对于同一数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock接口的实现都是悲观锁。 使用场景悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。 乐观锁概念乐观锁在使用数据时会认为不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。在Java中，最常用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。 使用场景乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。 CAS算法三个操作数 需要读写的内存值 V 进行比较的值 A 要写入的值 B 实现过程当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。 JDK实现Java.util.concurrent包的原子类，就是通过CAS实现了乐观锁，我们进入AtomicInteger看一下： 123456789101112131415public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; unsafe： 获取并操作内存的数据。 valueOffset： 存储value在AtomicInteger中的偏移量。 value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。 接下来看一下在AtomicInteger中自增函数incrementAndGet()中，底层使用的是unsafe.getAndAddInt()。JDK中的变量名不知道什么意思，所以在OpenJDK中进行查看。 123456789101112131415161718192021222324// ------------------------- JDK 8 -------------------------// AtomicInteger 自增方法public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;// Unsafe.classpublic final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125;// ------------------------- OpenJDK 8 -------------------------// Unsafe.javapublic final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125; 根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。 后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。 存在的问题ABA的问题 CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。 JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。 循环时间长开销大CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。 只能保证一个共享变量的原子操作 对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。 Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java多线程之ThreadLocal]]></title>
    <url>%2F2017%2F07%2F04%2F20170704-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThreadLocal%2F</url>
    <content type="text"><![CDATA[概述ThreadLocal提供了线程的局部变量，且不会和其他线程的局部变量冲突，实现了线程的数据隔离。 主要接口 set(value) 获取当前线程的threadLocals变量（ThreadLocal类型） 如果为null，进行初始化map 否则将值存入map中，调用map的set方法，ThreadLocal作为key get() ThreadLocal作为key remove() initialValue() ThreadLocalMapThreadLocalMap是ThreadLocal的内部类。 每个Thread维护了一个ThreadLocalMap的引用（threadLocals变量）。 Entry 继承WeakReference ThreadLocal的内部类 真正存储值的地方 重要成员 Entry[] table：默认大小为16 set(ThreadLocal&lt;?&gt; key, Object value) getEntry(ThreadLocal&lt;?&gt; key) hash冲突解决方式开放式定址发法 线性探测法 冲突发生时，顺序查看表中的下一单元，直到找出一个空单元或者遍历全表。如ThreadLocal采用这种方式。 二次探测冲突发生时，在表的左右进行跳跃式的探测，比较灵活。 伪随机探测 具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。 链地址法（链表） 如HashMap的实现 再哈希法 有多个不同的hash函数，当发生冲突时，使用第二个，第三个，…等哈希函数，计算地址，直到无冲突 虽然不容易发生聚集，但是增加了计算时间 建立公共溢出区将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表 rehash长度大于等于threshold（length的3分之2） resize 长度大于等于（threshold - threshold/4） 扩容为原来的2倍 内存泄漏ThreadLocal在没有外部对象强引用时，GC时会将key回收，而value不会回收，这时候ThreadLocalMap中就会存在key为null但是value不为null的entry，这时线程一直运行的话，value得不到回收，发生内存泄漏。 解决方式调用ThreadLocal的remove方法来显示清理key为null的元素。 根本原因ThreadLocalMap的生命周期和线程是一样的，如果没有手动删除key，对应的value就会内存泄漏。 应用场景 单个线程 线程上下文信息存储 数据库连接 session管理]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解C#中的String]]></title>
    <url>%2F2017%2F05%2F23%2F20170523-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%85%A5CSharp%E4%B8%AD%E7%9A%84String%2F</url>
    <content type="text"><![CDATA[关于C#中的类型在C#中类型分为值类型和引用类型，引用类型和值类型都继承自System.Object类,几乎所有的引用类型都直接从System.Object继承，而值类型具体一点则继承System.Object的子类，即继承System.ValueType。而String类型却有点特别，虽然它属于引用类型，但是他的一些特性却有点类似值类型。 关于C# String1、不变性我们先来看看一个例子： 123456789static void Main(string[] args)&#123; string str1 = &quot;string&quot;; string str2 = str1; Console.WriteLine(object.ReferenceEquals(str1, str2)); str2 += &quot;change&quot;; Console.WriteLine(object.ReferenceEquals(str1, str2)); Console.ReadKey();&#125; 输出结果是True、False。为什么呢？我们来看看IL。 123456789101112131415161718192021222324252627.entrypoint // 代码大小 48 (0x30) .maxstack 2 .locals init ([0] string str1, [1] string str2) IL_0000: nop IL_0001: ldstr &quot;string&quot; IL_0006: stloc.0 IL_0007: ldloc.0 IL_0008: stloc.1 IL_0009: ldloc.0 IL_000a: ldloc.1 IL_000b: ceq IL_000d: call void [mscorlib]System.Console::WriteLine(bool) IL_0012: nop IL_0013: ldloc.1 IL_0014: ldstr &quot;change&quot; IL_0019: call string [mscorlib]System.String::Concat(string,string) IL_001e: stloc.1 IL_001f: ldloc.0 IL_0020: ldloc.1 IL_0021: ceq IL_0023: call void [mscorlib]System.Console::WriteLine(bool) IL_0028: nop IL_0029: call valuetype [mscorlib]System.ConsoleKeyInfo [mscorlib]System.Console::ReadKey() IL_002e: pop IL_002f: ret +=在内部调用了Concat函数，将str2和”change”连接起来直接生成了一个新的字符串，和原来的字符串是不同的对象。Trim、Remove函数都是会直接生成一个新的对象，字符串一经定义，就不能改变。 其实字符串具有原子性（也就是不变性），任何改变字符串的值的行为都不会成功，只会创建一个新的字符串对象。在实际编程中，我们会大量的使用字符串，这样就会导致不停地创建新的字符串对象和分配内存，可能导致垃圾回收器GC不停地进行垃圾回收，大大降低性能，并且伴随着内存溢出的危险。所以.Net对字符串进行了的特殊的处理，这就是字符串驻留池。 在字符串驻留池，保存着字符串字面值和指向的引用。每次有新的字符串创建，都会在驻留池中查找是否存在字面值相同的字符串，如果存在就将其指向已经存在的字符串的引用，不存在就直接新建一个字符串，然后指向一个新的地址。 2、作为函数参数的处理在函数的参数传递中，值类型直接拷贝变量保存的值，传递的是一个值得副本，而引用类型传递的是地址的一个副本，所以在函数中改变引用参数中属性的值会直接改变函数外真实类型对象的值。 123456789101112131415161718static void Main(string[] args)&#123; People people = new People() &#123; Name = &quot;Jack&quot; &#125;; Console.WriteLine(people.Name); Change(people); Console.WriteLine(people.Name); Console.ReadKey();&#125;static void Change(People p)&#123; p.Name = &quot;Eason&quot;;&#125;class People&#123; public string Name &#123; get; set; &#125;&#125; 程序先输出Jack，后输出Eason，可以说明引用类型传递的是引用地址，函数改变的参数对象和外部传递进来的对象是一个对象。 那么我们来看看String作为参数的情况： 1234567891011121314static void Main(string[] args)&#123; string str = &quot;string&quot;; Console.WriteLine(str); Change(str); Console.WriteLine(str); Console.ReadKey();&#125;static void Change(string str)&#123; str = &quot;change&quot;; Console.WriteLine(str);&#125; 结果输出string、change、string。调用Change函数后str的值还是”string”，由于字符串类型的不变性，在Change函数中对str进行赋值会重新创建一个新的字符串对象，然后为这个新的对象附上引用。所以虽然字符串类型是引用类型，但是在参数传递时它其实相当于值类型。 3、相等比较处理先看一个例子： 123456789101112string str1 = &quot;string&quot;;string str2 = &quot;string&quot;;string str3 = &quot;stringstring&quot;;string str4 = &quot;string&quot; + &quot;string&quot;;string str5 = str1 + &quot;string&quot;;Console.WriteLine(ReferenceEquals(str1, str2));Console.WriteLine(str1 == str2);Console.WriteLine(ReferenceEquals(str3, str4));Console.WriteLine(str3 == str4);Console.WriteLine(ReferenceEquals(str3, str5));Console.WriteLine(str3 == str5);Console.ReadKey(); 不出意外结果都应该为True，True，True，True，True，True，但是结果却是True，True，True，True，False，True，str3和str5不是一个对象，他们不是指向同一个地址，为什么呢？经过查看IL代码发现，str5在IL代码中调用了Concat函数将str1和”string”进行了拼接，那这个Concat函数到底做了什么。 1234567891011121314151617181920public static string Concat(string str0, string str1)&#123; if (IsNullOrEmpty(str0)) &#123; if (IsNullOrEmpty(str1)) &#123; return Empty; &#125; return str1; &#125; if (IsNullOrEmpty(str1)) &#123; return str0; &#125; int length = str0.Length; string dest = FastAllocateString(length + str1.Length); FillStringChecked(dest, 0, str0); FillStringChecked(dest, length, str1); return dest;&#125; FastAllocateString函数负责分配长度为str0.Length+str1.Length的空字符串dest，FillStringChecked分别将str0和str1复制到dest中，最后生成由str0和str1连接成的字符串，这样不会再去字符串驻留池中查找是否存在和dest相同的字符串，而是直接生成一个新的对象。所以字符串变量和字符串常量进行拼接后会直接生成一个新的对象，绕过驻留池检查。 而字符串常量拼接不会产生新的字符串，除非驻留池中没有与之拼接后字面值相等的字符串。我们来看看IL代码： 1234567891011121314IL_0001: ldstr &quot;string&quot;IL_0006: stloc.0IL_0007: ldstr &quot;string&quot;IL_000c: stloc.1IL_000d: ldstr &quot;stringstring&quot;IL_0012: stloc.2IL_0013: ldstr &quot;stringstring&quot;IL_0018: stloc.3IL_0019: ldloc.0IL_001a: ldstr &quot;string&quot;IL_001f: call string [mscorlib]System.String::Concat(string,string)IL_0024: stloc.s str5IL_0026: ldloc.0IL_0027: ldloc.1 str3和str4的字面值是相等的，都是”stringstring”，str3先于str4被初始化，当str4被初始化的时候，由于其字面值和str3相等，所以CLR会将str3指向的地址赋给str4，所以str3和str4引用是相等的。 至于”==”操作符的得到的结果都是True是因为”==”操作符会调用String.Equal方法，IL代码如下： 1IL_0032: call bool [mscorlib]System.String::op_Equality(string,string) op_Equality最终会调用String.Equal函数，Equal函数的比较步骤是先比较两个对象的引用是否相等，不相等的话再对值进行比较，比较值时是按位比较的。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub搭建静态博客]]></title>
    <url>%2F2016%2F12%2F09%2F20161209-Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[开始在安装hexo之前，必须确认你已经安装了Node.js和Git，并且注册了一个GitHub账号。 1.创建Github仓库1) 仓库名为xxx.github.io创建一个以”用户名.github.io”命名的仓库，如我的用户名为mroccyen,那我的仓库名为：mroccyen.github.io，仓库默认有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。 2) 仓库名为其他名称，如myblog如果是以其他名字命名的，如myblog，则需要建立一个gh-pages分支用于托管生成的静态文件，必须是gh-pages分支。后台文件可以托管在master分支上，也可以放在其他的分支。 2.配置Git设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入： 12$ git config --global user.name "username"$ git config --global user.email "email@example.com" 3.本地Git与Github建立联系这里介绍SSH的配置，先检查电脑是否已经有SSH 1$ ls -al ~/.ssh 如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。输入以下指令后，一路回车就好： 1$ ssh-keygen -t rsa -C "emailt@example.com" 然后键入以下指令： 12$ ssh-agent -s$ ssh-add ~/.ssh/id_rsa 如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可： 1$ ssh-agent bash 再重新输入指令： 1$ ssh-add ~/.ssh/id_rsa 到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）： 1$ clip &lt; ~/.ssh/id_rsa.pub 在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH keyTitle自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。最后还是测试一下吧，键入以下命令： 1$ ssh -T git@github.com 你可能会看到有警告，没事，输入“yes”就好。 4.初始化hexo文件夹如果建立的是xxx.github.io仓库，到GitHub的xxx.github.io仓库下，如果建立的是其他名字的仓库，则到其他名字仓库下，我这里是创建myblog，然后点击Clone or download，复制里面的HTTPS地址。在你本地电脑的文件夹下，右键Git Bash Here: 键入git clone &lt;刚复制的地址&gt;。 12$ git clone https://github.com/mroccyen/myblog.git$ mkdir myblog Hexo安装配置1.Hexo初始化进入myblog文件夹 1$ cd myblog 接下来只需要使用 npm 即可完成 Hexo 的安装，如果在当前的文件夹下始终安装失败，到C盘里去安装，会成功。 1$ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件: 12$ hexo init$ npm install 接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。 12$ hexo generate$ hexo server 输入Ctrl+C停止服务。 2.Hexo配置用编辑器打开 myblog/ 下的配置文件_config.yml找到： 12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: repository: 到GitHub的myblog仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: gh-pages 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/mroccyen/myblog.git branch: gh-pages 3.完成部署最后一步，快要成功了，键入指令： 123$ npm install hexo-deployer-git --save$ hexo generate$ hexo deploy 输入弹出框的用户名与密码(首次使用git会弹出)。OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：myblog每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样： 123To https://github.com/mroccyen/myblog.git 7f3b50a..128a10d HEAD -&gt; gh-pagesINFO Deploy done: git 这样生成的静态文件就上传到github的myblog仓库中的gh-pages分支中了。最后再把myblog文件夹中的所有文件上传到github中的myblog仓库中的master分之中。 日常操作1.写文章执行new命令，生成指定名称的文章至 myblog\source_posts\文章标题.md 。 1$ hexo new [layout] "文章标题" #新建文章 然后用编辑器打开“文章标题.md”按照Markdown语法书写文章。 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout， 同时你也可以编辑现有的layout，比如post的layout默认是 myblog\scaffolds\post.md 123456title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:- tag1- tag2--- 我想添加categories，以免每次手工输入，只需要修改这个文件添加如下行： 1234567title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories:- categories1- categories2tags:--- 文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。 2.提交每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。 123$ git add .$ git commit -m "你的描述"$ git push origin master 然后才执行hexo generate发布网站到gh-pages分支上。 1$ hexo generate 3.本地仓库丢失当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤： 1)拷贝仓库1$ git clone https://github.com/mroccyen/myblog.git 2)配置Hexo在本地新拷贝的myblog文件夹下通过Git bash依次执行下列指令: 1234$ npm install -g hexo-cli$ npm install hexo$ npm install$ npm install hexo-deployer-git --save 3)小Tips:hexo 命令1234567891011121314hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo deploy -g #生成加部署hexo server -g #生成加预览#命令的简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
